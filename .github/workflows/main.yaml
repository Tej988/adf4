on:
  push:
    branches:
      - adf_publish

permissions:
  id-token: write
  contents: read

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - name: Azure login
        uses: azure/login@v1.4.6
        with:
          creds: '{"clientId":"${{ secrets.CLIENT_ID }}","clientSecret":"${{ secrets.CLIENT_SECRET }}","subscriptionId":"${{ secrets.SUBSCRIPTION_ID }}","tenantId":"${{ secrets.TENANT_ID }}"}'
      
      - name: Get latest code
        uses: actions/checkout@v2

      - name: 'ADF triggers stop --> Deployment and triggers start step'
        uses: azure/powershell@v1
        with:
          inlineScript: |
            $ResourceGroupName = "Tej_RG"
            $DataFactoryName = "devadfbytej"

            param (
                [parameter(Mandatory = $false)]
                [String] $armTemplate,
                [parameter(Mandatory = $false)]
                [String] $ResourceGroupName,
                [parameter(Mandatory = $false)]
                [String] $DataFactoryName,
                [parameter(Mandatory = $false)]
                [Bool] $predeployment = $true,
                [parameter(Mandatory = $false)]
                [Bool] $deleteDeployment = $false
            )

            function getPipelineDependencies {
                param([System.Object] $activity)
                if ($activity.Pipeline) {
                    return @($activity.Pipeline.ReferenceName)
                } elseif ($activity.Activities) {
                    $result = @()
                    $activity.Activities | ForEach-Object { $result += getPipelineDependencies -activity $_ }
                    return $result
                } elseif ($activity.ifFalseActivities -or $activity.ifTrueActivities) {
                    $result = @()
                    $activity.ifFalseActivities | Where-Object { $_ -ne $null } | ForEach-Object { $result += getPipelineDependencies -activity $_ }
                    $activity.ifTrueActivities | Where-Object { $_ -ne $null } | ForEach-Object { $result += getPipelineDependencies -activity $_ }
                    return $result
                } elseif ($activity.defaultActivities) {
                    $result = @()
                    $activity.defaultActivities | ForEach-Object { $result += getPipelineDependencies -activity $_ }
                    if ($activity.cases) {
                        $activity.cases | ForEach-Object { $_.activities } | ForEach-Object { $result += getPipelineDependencies -activity $_ }
                    }
                    return $result
                } else {
                    return @()
                }
            }

            function pipelineSortUtil {
                param([Microsoft.Azure.Commands.DataFactoryV2.Models.PSPipeline] $pipeline,
                    [Hashtable] $pipelineNameResourceDict,
                    [Hashtable] $visited,
                    [System.Collections.Stack] $sortedList)
                if ($visited[$pipeline.Name] -eq $true) {
                    return;
                }
                $visited[$pipeline.Name] = $true;
                $pipeline.Activities | ForEach-Object { getPipelineDependencies -activity $_ -pipelineNameResourceDict $pipelineNameResourceDict } | ForEach-Object {
                    pipelineSortUtil -pipeline $pipelineNameResourceDict[$_] -pipelineNameResourceDict $pipelineNameResourceDict -visited $visited -sortedList $sortedList
                }
                $sortedList.Push($pipeline)
            }

            function Get-SortedPipelines {
                param(
                    [string] $DataFactoryName,
                    [string] $ResourceGroupName
                )
                $pipelines = Get-AzDataFactoryV2Pipeline -DataFactoryName $DataFactoryName -ResourceGroupName $ResourceGroupName
                $ppDict = @{}
                $visited = @{}
                $stack = New-Object System.Collections.Stack
                $pipelines | ForEach-Object { $ppDict[$_.Name] = $_ }
                $pipelines | ForEach-Object { pipelineSortUtil -pipeline $_ -pipelineNameResourceDict $ppDict -visited $visited -sortedList $stack }
                $sortedList = New-Object Collections.Generic.List[Microsoft.Azure.Commands.DataFactoryV2.Models.PSPipeline]

                while ($stack.Count -gt 0) {
                    $sortedList.Add($stack.Pop())
                }
                $sortedList
            }

            function triggerSortUtil {
                param([Microsoft.Azure.Commands.DataFactoryV2.Models.PSTrigger] $trigger,
                    [Hashtable] $triggerNameResourceDict,
                    [Hashtable] $visited,
                    [System.Collections.Stack] $sortedList)
                if ($visited[$trigger.Name] -eq $true) {
                    return;
                }
                $visited[$trigger.Name] = $true;
                if ($trigger.Properties.DependsOn) {
                    $trigger.Properties.DependsOn | Where-Object { $_ -and $_.ReferenceTrigger } | ForEach-Object {
                        triggerSortUtil -trigger $triggerNameResourceDict[$_.ReferenceTrigger.ReferenceName] -triggerNameResourceDict $triggerNameResourceDict -visited $visited -sortedList $sortedList
                    }
                }
                $sortedList.Push($trigger)
            }

            function Get-SortedTriggers {
                param(
                    [string] $DataFactoryName,
                    [string] $ResourceGroupName
                )
                $triggers = Get-AzDataFactoryV2Trigger -ResourceGroupName $ResourceGroupName -DataFactoryName $DataFactoryName
                $triggerDict = @{}
                $visited = @{}
                $stack = New-Object System.Collections.Stack
                $triggers | ForEach-Object { $triggerDict[$_.Name] = $_ }
                $triggers | ForEach-Object { triggerSortUtil -trigger $_ -triggerNameResourceDict $triggerDict -visited $visited -sortedList $stack }
                $sortedList = New-Object Collections.Generic.List[Microsoft.Azure.Commands.DataFactoryV2.Models.PSTrigger]

                while ($stack.Count -gt 0) {
                    $sortedList.Add($stack.Pop())
                }
                $sortedList
            }

            function Get-SortedLinkedServices {
                param(
                    [string] $DataFactoryName,
                    [string] $ResourceGroupName
                )
                $linkedServices = Get-AzDataFactoryV2LinkedService -ResourceGroupName $ResourceGroupName -DataFactoryName $DataFactoryName
                $LinkedServiceHasDependencies = @('HDInsightLinkedService', 'HDInsightOnDemandLinkedService', 'AzureBatchLinkedService')
                $Akv = 'AzureKeyVaultLinkedService'
                $HighOrderList = New-Object Collections.Generic.List[Microsoft.Azure.Commands.DataFactoryV2.Models.PSLinkedService]
                $RegularList = New-Object Collections.Generic.List[Microsoft.Azure.Commands.DataFactoryV2.Models.PSLinkedService]
                $AkvList = New-Object Collections.Generic.List[Microsoft.Azure.Commands.DataFactoryV2.Models.PSLinkedService]

                $linkedServices | ForEach-Object {
                    if ($_.Properties.GetType().Name -in $LinkedServiceHasDependencies) {
                        $HighOrderList.Add($_)
                    } elseif ($_.Properties.GetType().Name -eq $Akv) {
                        $AkvList.Add($_)
                    } else {
                        $RegularList.Add($_)
                    }
                }

                $SortedList = New-Object Collections.Generic.List[Microsoft.Azure.Commands.DataFactoryV2.Models.PSLinkedService]($HighOrderList.Count + $RegularList.Count + $AkvList.Count)
                $SortedList.AddRange($HighOrderList)
                $SortedList.AddRange($RegularList)
                $SortedList.AddRange($AkvList)
                $SortedList
            }

            $templateJson = Get-Content $armTemplate | ConvertFrom-Json
            $resources = $templateJson.resources

            # Triggers
            Write-Host "Getting triggers"
            $triggersInTemplate = $resources | Where-Object { $_.type -eq "Microsoft.DataFactory/factories/triggers"
